#!/usr/bin/python2
# -*- coding: utf8 -*-


# code tokens ###################################################################################
class Codes(object):
    """ Some text constants and code generations helpers.
    
    Objects generated by this class act as an intermediate language before outputting the final
    assembly code. """

    # Instruction types.
    PUSH = 0
    POP = 1
    MOV = 2

    JUMP = 10  # bare jump to a label
    IF_JUMP = 11  # all kinds of conditional jumps
    LABEL = 12
    CALL = 13
    ENTER = 14  # standard function prologue, not the asm 'enter' instruction
    LEAVE = 15  # standard function epilogue: asm 'leave' and 'ret'

    ADD = 20
    SUB = 21
    MUL = 22
    DIV = 23
    NEG = 24  # integer negation
    BOOL_VAL = 25  # evaluate a boolean value (e.g. when not used as part of a condition)
    BOOL_OP = 26 # evaluate a boolean operator (as above)

    CHILD = 90  # a special instruction saying "insert i-th child code here"
    ASM = 91  # used for all special asm lines like .file, .text, .string, .globl, etc
    EMPTY = 92  # empty output line, just to improve assembly readability

    _CODE_NAMES = {
        0: ['PUSH', 'POP', 'MOV'],
        1: ['JUMP', 'IF_JUMP', 'LABEL', 'CALL', 'ENTER', 'LEAVE'],
        2: ['ADD', 'SUB', 'MUL', 'DIV', 'NEG', 'BOOL_VAL', 'BOOL_OP'],
        9: ['CHILD', 'ASM', 'EMPTY'],
    }

    @classmethod
    def _code_name(cls, type):
        return cls._CODE_NAMES[type/10][type%10]

    var_size = 4  # every type uses 4 bytes for now
    strcat_function = 'concatString'  # runtime library functions for '+' string operator

    _labels = 1

    @classmethod
    def new_label(cls):
        cls._labels += 1
        return '.L%d' % cls._labels

    @classmethod
    def is_child(cls, instr):
        return instr['type'] == cls.CHILD

    @classmethod
    def mkcode(cls, type, **kwargs):
        d = kwargs.copy()
        d['type'] = type
        return d

    _strings = {}

    @classmethod
    def string_literal_label(cls, string):
        """ Return a label for a string literal ('.LCx'), but store each constant only once. """
        if string.value not in cls._strings:
            label = '.LC%d' % len(cls._strings)
            cls._strings[string.value] = label
            return label
        return cls._strings[string.value]

    #@classmethod
    #def str_instr(cls, instr):
        #""" Convert the internal intermediate language to a list of assembly instructions. """
        #for case in switch(instr['type']):
            #if case(cls.CHILD):
                ## TODO
            #if case(cls.LABEL):
                #yield instr['label'] + ':'
                #break
            #if case():
                #if len(instr) > 1:
                    #args = '\t' + ', '.join(instr[1:])
                #else:
                    #args = ''
                #yield self._gen_instr(instr[0] + args)

        ## TODO
        #instr = instr.replace(', #', '  #')
        #""" Some minimal output formatting. """
        #if (instr[:1] != '.' or instr.startswith('.string')) and instr[-1:] != ':':
            #instr = '\t' + instr
        #debug(instr)
        #return instr

        # ENTER
        #self.add_instr(['pushl', Codes.ebp])
        #self.add_instr(['movl', Codes.top, Codes.ebp])
        ## first local variable is at -4(%ebp), hence var_count+1
        #self.add_instr(['subl', Codes.const((self.var_count+1) * Codes.var_size), Codes.top])

        # BOOL NOT VAL
                #self.add_instr(['cmpl', Codes.const(0), Loc.reg('a')])
                #self.add_instr(['sete', Codes.regcmp])
                #self.add_instr(['movzbl', Codes.regcmp, Loc.reg('a')])
        
        # DIV
                #self.add_instr(['cdq'])
                #self.add_instr(['idivl', Loc.reg('c')])  # quotient in eax, remainder in edx

class Loc(object):
    """ Helper class for Codes to represent various locations where a value can be. """
    reg_a = '%eax'
    reg_d = '%edx'
    reg_c = '%ecx'

    # Note: cdecl needs EBP, ESI, EDI, EBX preserved.
    top = '%esp'
    ebp = '%ebp'
    regcmp = '%al'

    @staticmethod
    def const(n):
        return {'const': n}

    @staticmethod
    def reg(which):
        return {'reg': which}

    @classmethod
    def mem(cls, addr, offset=None):
        if offset:
            return {'mem': cls.mkaddr(addr, offset)}
        return {'mem': addr}

    @staticmethod
    def stringlit(obj):
        return {'stringlit': Codes.string_literal_label(obj)}

    @classmethod
    def arg_addr(cls, n):
        """ Address of n-th function argument. """
        return cls.mkaddr(cls.ebp, Codes.var_size * (n+2))

    @classmethod
    def var_addr(cls, n):
        """ Address of n-th local variable on stack. """
        return cls.mkaddr(cls.ebp, Codes.var_size * (-1-n))

    @staticmethod
    def mkaddr(pos, offset=None):
        return '%s(%s)' % (str(offset or ''), pos)
